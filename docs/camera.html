<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mi Crono — Cámara</title>
  <link rel="stylesheet" href="styles.css"/>
  <style>
    :root { --hud-bg: rgba(0,0,0,.55); }
    .ok{color:#0a7a0a;font-weight:600}
    .err{color:#b00020;font-weight:600}
    .muted{opacity:.8}
    .debug{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#f6f6f6;border-radius:8px;padding:10px}
    .stage{position:relative;margin-top:10px;border-radius:16px;overflow:hidden;height:75vh;background:#000;display:flex;align-items:center;justify-content:center}
    video{width:100%;height:100%;object-fit:cover;background:#000;display:block}
    canvas.overlay{position:absolute;inset:0;pointer-events:none}
    .hud{position:absolute;left:12px;right:12px;top:12px;background:var(--hud-bg);color:#fff;border-radius:14px;padding:10px 14px;font-weight:600;backdrop-filter:blur(4px)}
    .timer{position:absolute;left:12px;right:12px;bottom:12px;background:var(--hud-bg);color:#fff;border-radius:22px;padding:18px 22px;font-size:42px;font-weight:800;text-align:center;letter-spacing:.5px;backdrop-filter:blur(4px)}
    .row.gap > *{margin-right:8px}
    input[type=range]{width:100%}
    .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#eef;color:#123}
    .list{margin-top:12px}
    .runner{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:1px solid #e8e8f0;border-radius:10px;background:#fff;margin-bottom:6px}
    .runner .time{font-weight:700}
  </style>
</head>
<body class="wrap">
  <header class="top">
    <h1 id="title">Modo cámara</h1>
    <p class="tag" id="tag">Conectando…</p>
  </header>

  <main class="grid one">
    <section class="card warn" id="noCodeBox" style="display:none">
      <b>Falta el código de evento.</b> Vuelve a <a href="index.html">Inicio</a> y crea/únete a un evento.
    </section>

    <section class="card">
      <div class="row gap">
        <button id="btnEnableCam" class="btn primary">Activar cámara</button>
        <button id="btnStart" class="btn">Marcar INICIO</button>
        <button id="btnStop" class="btn">Marcar FIN</button>
        <a id="btnResult" class="btn" href="#">Ver resultado</a>
      </div>
      <small class="muted">iOS: Safari + HTTPS + permitir Cámara.</small>

      <div class="stage" id="stage">
        <video id="video" playsinline muted></video>
        <canvas id="overlay" class="overlay"></canvas>

        <div class="hud" id="hudTop">
          <span id="hudStatus">Listo</span>
          • <span id="hudNext" class="pill">Siguiente: —</span>
        </div>
        <div class="timer" id="timerText">00:00.000 — <span id="runnerName">—</span></div>
      </div>

      <div class="card" style="margin-top:12px">
        <label>Sensibilidad detector (franja roja)</label>
        <input id="sens" type="range" min="1" max="100" value="25"/>
        <small class="muted">Más a la derecha = más sensible.</small>
      </div>

      <div class="card list">
        <h3>En curso</h3>
        <div id="runningList">—</div>
      </div>
    </section>

    <section class="card">
      <h2>Estado</h2>
      <div>Firebase: <span id="fbState">—</span></div>
      <div>Evento: <span id="evState">—</span></div>
      <div>Última acción: <span id="lastAction">—</span></div>
    </section>

    <section class="card">
      <h2>Depuración</h2>
      <div class="debug" id="lastError">—</div>
    </section>
  </main>

  <footer><a class="linklike" href="index.html">⇦ Volver a Inicio</a></footer>

  <script type="module">
    // ===== Utils & UI =====
    const $ = (id)=>document.getElementById(id);
    const two = (n)=> String(n).padStart(2,'0');
    const three = (n)=> String(n).padStart(3,'0');
    const fmt = (ms)=>{ ms=Math.max(0,Math.floor(ms||0));
      const m=Math.floor(ms/60000), s=Math.floor((ms%60000)/1000), ms3=ms%1000;
      return `${two(m)}:${two(s)}.${three(ms3)}`; };

    const getParam = (k)=> new URL(location.href).searchParams.get(k);
    const code=(getParam('code')||'').toUpperCase();
    const mode=(getParam('mode')||'start'); // start|finish

    const title=$('title'), tag=$('tag'), hudStatus=$('hudStatus'), hudNext=$('hudNext'), timerText=$('timerText'), runnerName=$('runnerName'), runningList=$('runningList');
    const fbState=$('fbState'), evState=$('evState'), lastErrorEl=$('lastError'), lastAction=$('lastAction');
    const btnEnable=$('btnEnableCam'), btnStart=$('btnStart'), btnStop=$('btnStop'), btnResult=$('btnResult');
    const stage=$('stage'), video=$('video'), overlay=$('overlay'), sens=$('sens');
    const octx=overlay.getContext('2d',{willReadFrequently:true});

    title.textContent=`Modo ${mode==='start'?'SALIDA':'META'}`; tag.textContent=`Evento ${code||'—'}`;

    // ===== Estado =====
    window.__firebaseReady=false; window.__firebaseError=null;
    const paintFirebase=()=>{ fbState.textContent=window.__firebaseReady?'OK':'ERROR';
      fbState.className=window.__firebaseReady?'ok':'err';
      lastErrorEl.textContent=window.__firebaseReady?'—':('Init Firebase: '+(window.__firebaseError?.message||String(window.__firebaseError)||'sin detalle')); };

    if(!code){ $('noCodeBox').style.display=''; evState.textContent='SIN CÓDIGO'; evState.className='err'; }
    else { evState.textContent=code; evState.className='ok'; }
    btnResult.onclick=(e)=>{ e.preventDefault(); location.href=`result.html?code=${encodeURIComponent(code)}`; };

    // ===== Crono principal (informativo) =====
    let startMS=null, stopMS=null, running=false, currentRunner=null; // {id,name,order}
    setInterval(()=>{
      const nameText = currentRunner?.name || '—';
      if(running && startMS){ timerText.innerHTML = fmt(Date.now()-startMS) + ' — <span>'+ nameText +'</span>'; }
      else if(startMS && stopMS){ timerText.innerHTML = fmt(stopMS-startMS) + ' — <span>'+ nameText +'</span>'; }
      else { timerText.innerHTML = '00:00.000 — <span>'+ nameText +'</span>'; }
      renderRunningList();
    }, 80);

    const startLocal = (ms, runner)=>{
      if(running) return;
      startMS = ms || Date.now(); stopMS=null; running=true; currentRunner = runner || currentRunner;
      hudStatus.textContent = (mode==='start'?'SALIDA':'META') + ' — Crono en marcha';
    };
    const stopLocal = (ms)=>{
      if(!running) return;
      stopMS = ms || Date.now(); running=false;
      hudStatus.textContent = (mode==='start'?'SALIDA':'META') + ' — Crono detenido';
    };

    // ===== Firebase (CDN) =====
    let db, eventRef, partsCol, participants=[];
    const tsToMillis = (ts)=> ts ? (typeof ts==='number'?ts:(ts.seconds*1000+Math.floor((ts.nanoseconds||0)/1e6))) : null;

    try{
      const { initializeApp, getApp, getApps } = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js');
      const {
        getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp,
        collection, query, orderBy, getDocs, runTransaction
      } = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js');

      const firebaseConfig = {
        apiKey: "AIzaSyCt52Q6LEJ0fl0iKUIE6OKXlbp42fzOgBU",
        authDomain: "mi-crono-time-888b7.firebaseapp.com",
        projectId: "mi-crono-time-888b7",
        storageBucket: "mi-crono-time-888b7.appspot.com",
        messagingSenderId: "379025900327",
        appId: "1:379025900327:web:6f10f46ee086ca61f8df02"
      };

      const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
      db = getFirestore(app);
      window.__firebaseReady=true; paintFirebase();

      if(code){
        eventRef = doc(db,'events',code);
        partsCol = collection(eventRef,'participants');

        const reloadOrdered = async ()=>{
          const snap = await getDocs(query(partsCol, orderBy('order','asc')));
          participants = snap.docs.map(d=>({ id:d.id, ref:d.ref, ...d.data() }));
          return participants;
        };

        // Crear evento si no existe
        const s=await getDoc(eventRef);
        if(!s.exists()) await setDoc(eventRef,{code,createdAt:serverTimestamp()},{merge:true});

        // Helpers SALIDA/META (selección local con snapshot)
        const nextToStart = ()=> participants.find(p=>!p.startClientMS && !p.startTS);
        const runningSorted = ()=> participants
          .filter(p=>(p.startClientMS||p.startTS) && !(p.stopClientMS||p.stopTS))
          .sort((a,b)=>(a.startClientMS ?? tsToMillis(a.startTS)) - (b.startClientMS ?? tsToMillis(b.startTS)));

        // ----------- TRANSACCIONES -----------
        const txStartNext = async ()=>{
          return runTransaction(db, async (tx)=>{
            const snap = await tx.get(query(partsCol, orderBy('order','asc')));
            const list = snap.docs.map(d=>({ id:d.id, ref:d.ref, ...d.data() }));
            const nxt  = list.find(p=>!p.startClientMS && !p.startTS);
            if(!nxt) return null;
            tx.update(nxt.ref, { startTS:serverTimestamp(), startClientMS: Date.now(), stopTS:null, stopClientMS:null });
            return { id:nxt.id, name:nxt.name, order:nxt.order, startClientMS: Date.now() };
          });
        };

        const txStopEarliest = async ()=>{
          return runTransaction(db, async (tx)=>{
            const snap = await tx.get(query(partsCol, orderBy('order','asc')));
            const list = snap.docs.map(d=>({ id:d.id, ref:d.ref, ...d.data() }));
            // FIFO real: el que tenga start y aún no tenga stop, con menor startClientMS/TS
            const running = list
              .filter(p=>(p.startClientMS||p.startTS) && !(p.stopClientMS||p.stopTS))
              .sort((a,b)=>( (a.startClientMS ?? tsToMillis(a.startTS)) - (b.startClientMS ?? tsToMillis(b.startTS)) ));
            const cur = running[0];
            if(!cur) return null; // META no toca nada si no hay nadie corriendo
            // marca stop sólo si sigue sin stop (idempotente)
            tx.update(cur.ref, { stopTS:serverTimestamp(), stopClientMS: Date.now() });
            return { id:cur.id, name:cur.name, order:cur.order, stopClientMS: Date.now() };
          });
        };
        // -------------------------------------

        // SNAPSHOT: NO se auto-inicia en META; sólo refleja estado
        onSnapshot(partsCol, async ()=>{
          await reloadOrdered();

          const running = runningSorted();
          const nextOne = nextToStart();

          if(running.length>0){
            const first = running[0];
            const start = (first.startClientMS ?? tsToMillis(first.startTS) ?? Date.now());
            startLocal(start, { id:first.id, name:first.name, order:first.order }); // muestra el primero en curso
            $('runnerName').textContent = first.name || '—';
          } else {
            // No hay nadie corriendo -> parada visual; NO iniciar al "next"
            if(running) stopLocal();
            $('runnerName').textContent = nextOne?.name || '—';
          }

          hudNext.textContent = 'Siguiente: ' + (nextOne?.name || '—');
          const hasStart = participants.some(p=>p.startClientMS||p.startTS);
          const hasStop  = participants.some(p=>p.stopClientMS||p.stopTS);
          tag.textContent = `Evento ${code} • ${hasStart?'Inicio OK':'Sin inicio'} • ${hasStop?'Algún fin':''}`;
        },(err)=>{ lastErrorEl.textContent='Snapshot: '+(err.code||err.message||err); });

        // Botones
        btnStart.onclick = async ()=>{
          const r = await txStartNext(); // SALIDA decide el siguiente
          if(r){ startLocal(r.startClientMS, {id:r.id,name:r.name,order:r.order}); lastAction.textContent='Inicio: '+r.name; }
          else { lastAction.textContent='No hay siguiente para iniciar.'; }
        };
        btnStop.onclick  = async ()=>{
          const r = await txStopEarliest(); // META para al que va primero
          if(r){ stopLocal(r.stopClientMS); lastAction.textContent='Fin: '+r.name; }
          else { lastAction.textContent='No hay participante en curso.'; }
        };

        // ===== Cámara + detección =====
        btnEnable.onclick = async ()=>{
          try{
            if(!navigator.mediaDevices?.getUserMedia){ alert('Navegador sin cámara'); return; }
            const tries=[{video:{facingMode:{ideal:'environment'}},audio:false},{video:{facingMode:'environment'},audio:false},{video:true,audio:false}];
            let stream=null,lastErr=null;
            for(const c of tries){ try{ stream=await navigator.mediaDevices.getUserMedia(c); if(stream) break; } catch(e){ lastErr=e; } }
            if(!stream){ alert('No se pudo abrir la cámara.\n'+(lastErr?.name+': '+lastErr?.message)); return; }
            video.setAttribute('playsinline','true'); video.muted=true; video.srcObject=stream;
            await new Promise(res=>{ if(video.readyState>=2) res(); else video.onloadedmetadata=()=>res(); }); await video.play();
            btnEnable.textContent='Cámara activada'; btnEnable.disabled=true;
            requestAnimationFrame(loop);
          }catch(e){ alert('Error cámara: '+(e?.message||e)); }
        };

        // Detección por franja central
        let prev=null, armed=true;
        const trigger = async ()=>{
          if(!armed) return; armed=false; setTimeout(()=>armed=true,1000);
          if(mode==='start'){
            const r=await txStartNext(); // SALIDA inicia al siguiente (no auto–arranque en META)
            if(r){ startLocal(r.startClientMS, {id:r.id,name:r.name,order:r.order}); }
          } else {
            const r=await txStopEarliest(); // META para al primero en curso
            if(r){ stopLocal(r.stopClientMS); }
          }
        };

        function loop(){
          const w=overlay.width=stage.clientWidth, h=overlay.height=stage.clientHeight;
          const roiWidth=Math.round(w*0.08), cx=Math.round(w*0.5), x1=cx-Math.round(roiWidth/2), x2=cx+Math.round(roiWidth/2);
          octx.clearRect(0,0,w,h);
          octx.fillStyle='rgba(255,0,0,.3)'; octx.fillRect(x1,0,2,h); octx.fillRect(x2-2,0,2,h);
          octx.fillStyle='rgba(255,0,0,.18)'; octx.fillRect(x1,0,roiWidth,h);

          const vw=video.videoWidth, vh=video.videoHeight;
          if(vw && vh){
            const scaleX = vw / stage.clientWidth;
            const sx=Math.max(0, Math.min(vw-1, Math.round(x1*scaleX)));
            const sw=Math.max(1, Math.min(vw-sx, Math.round(roiWidth*scaleX)));
            const tmp=document.createElement('canvas'); tmp.width=vw; tmp.height=vh;
            const tctx=tmp.getContext('2d',{willReadFrequently:true}); tctx.drawImage(video,0,0,vw,vh);
            const frame=tctx.getImageData(sx,0,sw,vh);

            if(prev && prev.width===sw && prev.height===vh){
              const sensV=Number(sens.value); const thr=20+Math.round((100-sensV)*1.2); const pct=0.04+(100-sensV)*0.0006;
              let diff=0,total=0;
              for(let i=0;i<frame.data.length;i+=16){
                const d = Math.abs(frame.data[i]-prev.data[i]) + Math.abs(frame.data[i+1]-prev.data[i+1]) + Math.abs(frame.data[i+2]-prev.data[i+2]);
                if(d>thr) diff++; total++;
              }
              if((diff/Math.max(1,total))>pct) trigger();
            }
            prev=frame;
          }
          requestAnimationFrame(loop);
        }

        function renderRunningList(){
          if(!participants.length) { runningList.innerHTML='—'; return; }
          const now = Date.now();
          const runningArr = runningSorted();
          if(!runningArr.length){ runningList.innerHTML='—'; return; }
          runningList.innerHTML = runningArr.map(p=>{
            const st = (p.startClientMS ?? tsToMillis(p.startTS) ?? now);
            return `<div class="runner"><div>${p.order}. ${p.name}</div><div class="time">${fmt(now - st)}</div></div>`;
          }).join('');
        }
      }
    }catch(e){ window.__firebaseError=e; window.__firebaseReady=false; paintFirebase(); }
    paintFirebase();
  </script>
</body>
</html>
